@page "/"
@using WellKnownProblems.Services
@inject StampedeService StampedeService
@inject RealTimeLogService LogService
@implements IDisposable
@inject IJSRuntime JSRuntime

<h1>Stampede Problem Demo</h1>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h1 class="display-4 text-center mb-4">Stampede Problem Demonstration</h1>
            <p class="lead text-center">
                This demo shows the "Thundering Herd" or "Stampede" problem where multiple threads 
                compete for the same resources, potentially causing deadlocks or performance issues.
            </p>
        </div>
    </div>

    <div class="row">
        <!-- Control Panel -->
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <h5>üîß Control Panel</h5>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Number of Concurrent Tasks:</label>
                        <input type="number" @bind="concurrentTasks" class="form-control" min="1" max="10" />
                    </div>
                    
                    <div class="d-grid gap-2">
                        <button class="btn btn-success" @onclick="RunNormalStampede" disabled="@isRunning">
                            ‚ñ∂Ô∏è Run Normal Stampede
                        </button>
                        
                        <button class="btn btn-warning" @onclick="RunDeadlockStampede" disabled="@isRunning">
                            ‚ö†Ô∏è Run Deadlock-Prone Stampede
                        </button>
                        
                        <button class="btn btn-info" @onclick="RunBothSimultaneously" disabled="@isRunning">
                            üîÑ Run Both Types
                        </button>
                        
                        <button class="btn btn-secondary" @onclick="ClearLogs">
                            üóëÔ∏è Clear Logs
                        </button>
                    </div>
                    
                    @if (isRunning)
                    {
                        <div class="mt-3 text-center">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Running...</span>
                            </div>
                            <p class="mt-2">Tasks are running...</p>
                        </div>
                    }
                </div>
            </div>

            <!-- Results Summary -->
            <div class="card mt-3">
                <div class="card-header">
                    <h6>üìä Results Summary</h6>
                </div>
                <div class="card-body">
                    <small>
                        <strong>Total Tasks Run:</strong> @totalTasksRun<br />
                        <strong>Successful:</strong> <span class="text-success">@successfulTasks</span><br />
                        <strong>Failed:</strong> <span class="text-danger">@failedTasks</span><br />
                        <strong>Average Duration:</strong> @averageDuration ms
                    </small>
                </div>
            </div>
        </div>

        <!-- Real-time Log Console -->
        <div class="col-md-8">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>üíª Real-time Log Console</h5>
                    <div>
                        <small class="text-muted">Auto-scroll:</small>
                        <input type="checkbox" @bind="autoScroll" />
                    </div>
                </div>
                <div class="card-body p-0">
                    <div class="log-container" style="height: 500px; overflow-y: auto; background-color: #1e1e1e; color: #ffffff; font-family: 'Consolas', monospace; font-size: 12px;">
                        @foreach (var log in logEntries.TakeLast(100))
                        {
                            <div class="log-entry p-2 @GetLogCssClass(log.Level)" style="border-bottom: 1px solid #333;">
                                <span class="text-muted">[<span class="font-weight-bold">@log.Timestamp.ToString("HH:mm:ss.fff")</span>]</span>
                                <span class="badge badge-sm @GetLogBadgeClass(log.Level)">T@log.ThreadId</span>
                                <span class="text-info">[@log.Source]</span>
                                <span>@log.Message</span>
                            </div>
                        }
                        @if (!logEntries.Any())
                        {
                            <div class="p-3 text-center text-muted">
                                ‚ÑπÔ∏è No logs yet. Run a stampede to see real-time activity.
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private int concurrentTasks = 3;
    private bool isRunning = false;
    private bool autoScroll = true;
    private List<LogEntry> logEntries = new();
    
    // Statistics
    private int totalTasksRun = 0;
    private int successfulTasks = 0;
    private int failedTasks = 0;
    private string averageDuration = "0";

    protected override void OnInitialized()
    {
        LogService.LogEntryAdded += OnLogEntryAdded;
    }

    private void OnLogEntryAdded(LogEntry logEntry)
    {
        logEntries.Add(logEntry);
        InvokeAsync(StateHasChanged);
        
        if (autoScroll)
        {
            InvokeAsync(async () => 
            {
                await JSRuntime.InvokeVoidAsync("scrollToBottom", ".log-container");
            });
        }
    }

    private async Task RunNormalStampede()
    {
        isRunning = true;
        LogService.Log($"üöÄ Starting Normal Stampede with {concurrentTasks} concurrent tasks", LogLevel.Information, "Demo Controller");
        
        var tasks = new List<Task>();
        var startTime = DateTime.Now;
        
        for (int i = 0; i < concurrentTasks; i++)
        {
            tasks.Add(Task.Run(async () =>
            {
                try
                {
                    await StampedeService.GetResourcesNormalAsync();
                    Interlocked.Increment(ref successfulTasks);
                }
                catch
                {
                    Interlocked.Increment(ref failedTasks);
                }
                finally
                {
                    Interlocked.Increment(ref totalTasksRun);
                }
            }));
        }
        
        await Task.WhenAll(tasks);
        var duration = (DateTime.Now - startTime).TotalMilliseconds;
        averageDuration = $"{duration:F0}";
        
        LogService.Log($"‚úÖ Normal Stampede completed in {duration:F0}ms", LogLevel.Information, "Demo Controller");
        isRunning = false;
    }

    private async Task RunDeadlockStampede()
    {
        isRunning = true;
        LogService.Log($"‚ö†Ô∏è Starting Deadlock-Prone Stampede with {concurrentTasks} concurrent tasks", LogLevel.Warning, "Demo Controller");
        
        var tasks = new List<Task>();
        var startTime = DateTime.Now;
        
        for (int i = 0; i < concurrentTasks; i++)
        {
            tasks.Add(Task.Run(async () =>
            {
                try
                {
                    await StampedeService.GetResourcesWithDeadlockRiskAsync();
                    Interlocked.Increment(ref successfulTasks);
                }
                catch
                {
                    Interlocked.Increment(ref failedTasks);
                }
                finally
                {
                    Interlocked.Increment(ref totalTasksRun);
                }
            }));
        }
        
        try
        {
            // Add timeout to avoid hanging on deadlocks
            await Task.WhenAll(tasks).WaitAsync(TimeSpan.FromSeconds(30));
            var duration = (DateTime.Now - startTime).TotalMilliseconds;
            averageDuration = $"{duration:F0}";
            LogService.Log($"‚úÖ Deadlock-Prone Stampede completed in {duration:F0}ms", LogLevel.Information, "Demo Controller");
        }
        catch (TimeoutException)
        {
            LogService.Log($"üîí Deadlock-Prone Stampede timed out after 30s - likely deadlocked!", LogLevel.Error, "Demo Controller");
        }
        
        isRunning = false;
    }

    private async Task RunBothSimultaneously()
    {
        isRunning = true;
        LogService.Log($"üéØ Starting Mixed Stampede: Normal + Deadlock-Prone tasks", LogLevel.Information, "Demo Controller");
        
        var normalTasks = new List<Task>();
        var deadlockTasks = new List<Task>();
        var startTime = DateTime.Now;
        
        for (int i = 0; i < concurrentTasks / 2; i++)
        {
            normalTasks.Add(Task.Run(async () =>
            {
                try
                {
                    await StampedeService.GetResourcesNormalAsync();
                    Interlocked.Increment(ref successfulTasks);
                }
                catch
                {
                    Interlocked.Increment(ref failedTasks);
                }
                finally
                {
                    Interlocked.Increment(ref totalTasksRun);
                }
            }));
            
            deadlockTasks.Add(Task.Run(async () =>
            {
                try
                {
                    await StampedeService.GetResourcesWithDeadlockRiskAsync();
                    Interlocked.Increment(ref successfulTasks);
                }
                catch
                {
                    Interlocked.Increment(ref failedTasks);
                }
                finally
                {
                    Interlocked.Increment(ref totalTasksRun);
                }
            }));
        }
        
        try
        {
            var allTasks = normalTasks.Concat(deadlockTasks).ToArray();
            await Task.WhenAll(allTasks).WaitAsync(TimeSpan.FromSeconds(30));
            var duration = (DateTime.Now - startTime).TotalMilliseconds;
            averageDuration = $"{duration:F0}";
            LogService.Log($"‚úÖ Mixed Stampede completed in {duration:F0}ms", LogLevel.Information, "Demo Controller");
        }
        catch (TimeoutException)
        {
            LogService.Log($"üîí Mixed Stampede timed out - deadlock detected!", LogLevel.Error, "Demo Controller");
        }
        
        isRunning = false;
    }

    private void ClearLogs()
    {
        logEntries.Clear();
        totalTasksRun = 0;
        successfulTasks = 0;
        failedTasks = 0;
        averageDuration = "0";
        LogService.ClearLogs();
    }

    private string GetLogCssClass(LogLevel level) => level switch
    {
        LogLevel.Error => "text-danger",
        LogLevel.Warning => "text-warning",
        LogLevel.Information => "text-light",
        LogLevel.Debug => "text-muted",
        _ => "text-light"
    };

    private string GetLogBadgeClass(LogLevel level) => level switch
    {
        LogLevel.Error => "bg-danger",
        LogLevel.Warning => "bg-warning",
        LogLevel.Information => "bg-info",
        LogLevel.Debug => "bg-secondary",
        _ => "bg-primary"
    };

    public void Dispose()
    {
        LogService.LogEntryAdded -= OnLogEntryAdded;
    }
}
